```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(sf)
library(leaflet)
library(htmlwidgets)
library(tidycensus)
library(dplyr)
library(purrr)
```

```{r read-shapefiles}
# Define file paths
maz_path <- "C:/GitHub/tm2py-utils/tm2py_utils/inputs/maz_taz/shapefiles/mazs_TM2_v2_2.shp"
# the maz file already has the tazs on there

# Read shapefiles
mazs <- st_read(maz_path, quiet = TRUE)


# Reproject to WGS84 for Leaflet and tidycensus compatibility
crs_target <- 4326
mazs_wgs <- st_transform(mazs, crs_target)


# Fix invalid geometries
mazs_wgs <- st_make_valid(mazs_wgs)

```

```{r fetch-blocks, message=FALSE}
# Set your Census API key (run once)
key_path <- "M:/Data/Census/new_key/api-key"
if (file.exists(key_path)) {
  key <- readLines(key_path)
  census_api_key(key, install = TRUE, overwrite = TRUE)
} else {
  # Fallback: use existing environment variable or manually set
  if (Sys.getenv("CENSUS_API_KEY") == "") {
    stop("Census API key not found. Place it in M:/census_api_key.txt or set CENSUS_API_KEY env var.")
  }
}

# Identify unique state and counties in the TAZ shapefile
state_fp   <- "06"  # California
county_fps <- c("001", "013", "041", "055", "075", "081", "085", "095", "097")

# Download 2020 Census blocks for each county
blocks_list <- map(county_fps, function(county) {
  get_decennial(
    geography = "block",
    variables = "P1_001N",  # total population; geometry only is needed
    year = 2020,
    state = state_fp,
    county = county,
    geometry = TRUE,
    output = "wide"
  )
})
blocks <- do.call(rbind, blocks_list)

# Transform blocks to match CRS
blocks_wgs <- st_transform(blocks, crs_target)
```

```{r spatial-intersect}
# Assign MAZ and TAZ to blocks via spatial join
blocks_maz_taz <- st_join(blocks_wgs, mazs_wgs, join = st_intersects, left = TRUE)

```

```{r make-csv}
# Prepare lookup table
lookup_df <- blocks_maz_taz %>%
  st_drop_geometry() %>%
  transmute(
    GEOID20 = GEOID,
    maz      = maz,
    taz      = taz
  )

# Write CSV
write.csv(lookup_df, "block_maz_taz_20.csv", row.names = FALSE)
```
```{r}
library(dplyr)

# Suppose `blocks_maz_taz` is your joined sf, and `lookup_df` is the st_drop_geometry() version
# 1) How many MAZs per block?
blocks_per_block <- lookup_df %>%
  count(GEOID20, name = "maz_count")

# 2) Summary stats
blocks_per_block %>%
  summarise(
    total_blocks      = n(),
    avg_maz_per_block = mean(maz_count),
    max_maz_for_block = max(maz_count),
    blocks_with_multi = sum(maz_count > 1)
  )
# This will tell you how many blocks overlap more than one MAZ, and by how many on average.

# 3) How many blocks per MAZ?
blocks_per_maz <- lookup_df %>%
  count(maz, name = "block_count")

# 4) Where are the hotspots?
#    e.g. list blocks that overlap > 10 MAZs
blocks_per_block %>%
  filter(maz_count > 10) %>%
  arrange(desc(maz_count))
```

```{r leaflet-map, message=FALSE}
# Create interactive map including blocks
map <- leaflet() %>%
  addTiles() %>%
  addPolygons(data = tazs_wgs,
              color = "black", weight = 1,
              fill = FALSE, group = "TAZs") %>%
  addPolygons(data = mazs_wgs,
              color = "blue", fillOpacity = 0.3,
              group = "MAZs") %>%
  addPolygons(data = blocks_wgs,
              color = "gray", weight = 0.2, fill = FALSE,
              group = "Blocks") %>%
  addLayersControl(
    overlayGroups = c("Blocks", "MAZs", "TAZs"),
    options = layersControlOptions(collapsed = FALSE)
  )

map
```

```{r save-widget, eval=FALSE}
# Save the interactive map as a standalone HTML file
htmlwidgets::saveWidget(map, "maz_taz_block_map.html", selfcontained = TRUE)
```


