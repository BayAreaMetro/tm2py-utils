
---
title: "MAZ and Census Block 2020 analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(sf)
library(lwgeom)      # for st_make_valid
library(leaflet)
library(htmlwidgets)
library(tidycensus)
library(dplyr)
library(purrr)
```

```{r read-maz-shapefile}
# Define file paths

# Load MAZ shapefile from dissolved 2010 Blocks

maz_path <- "C:/GitHub/tm2py-utils/tm2py_utils/inputs/maz_taz/shapefiles/mazs_TM2_v2_2.shp"
mazs <- st_read(maz_path, quiet = TRUE)
mazs_wgs <- mazs %>%
  st_transform(4326) %>%
  st_make_valid()
```

```{r fetch-blocks, message=FALSE}
# Load Census API key
key_path <- "M:/Data/Census/new_key/api-key"
if (file.exists(key_path)) {
  key <- readLines(key_path)
  census_api_key(key, install = TRUE, overwrite = TRUE)
} else if (Sys.getenv("CENSUS_API_KEY") == "") {
  stop("Census API key not found. Place in M:/Data/Census/new_key/api-key or set CENSUS_API_KEY env var.")
}
# Define Bay Area FIPS
state_fp <- "06"
county_fps <- c("001","013","041","055","075","081","085","095","097")
# Download 2020 Census Blocks
tblocks <- map_dfr(county_fps, ~ get_decennial(
  geography = "block",
  variables = "P1_001N",
  year      = 2020,
  state     = state_fp,
  county    = .x,
  geometry  = TRUE,
  output    = "wide"
))
blocks_wgs <- tblocks %>%
  st_transform(4326) %>%
  st_make_valid()
```

```{r compute-areas-and-intersect}
# Compute area for blocks and MAZs
blocks_wgs <- blocks_wgs %>%
  mutate(block_area = as.numeric(st_area(geometry)))
mazs_wgs <- mazs_wgs %>%
  mutate(maz_area = as.numeric(st_area(geometry)))
# Intersection to compute percentage overlaps
intersect_bm <- st_intersection(blocks_wgs, mazs_wgs)
intersect_bm <- intersect_bm %>%
  mutate(
    area_int = as.numeric(st_area(geometry)),
    pct_block_in_maz = area_int / block_area,
    pct_maz_in_block = area_int / maz_area
  )
```

```{r write-out-lookup}
# Create lookup table of block to MAZ with overlap percentages
lookup_df <- intersect_bm %>%
  st_drop_geometry() %>%
  transmute(
    GEOID20 = GEOID,
    maz      = maz,
    pct_block_in_maz,
    pct_maz_in_block
  ) %>%
  distinct()
write.csv(lookup_df, "block_maz_lookup.csv", row.names = FALSE)
```

```{r diagnose-splits}
# Diagnose MAZ splits across blocks
maz_block_counts <- lookup_df %>%
  count(maz, name = "block_count") %>%
  arrange(desc(block_count))
print(summary(maz_block_counts$block_count))
single_block_mazs <- filter(maz_block_counts, block_count == 1)
cat("MAZs fully within one block:", nrow(single_block_mazs), "\n")
multi_block_mazs <- filter(maz_block_counts, block_count > 1)
cat("MAZs split across blocks:", nrow(multi_block_mazs), "\n")
write.csv(maz_block_counts, "maz_block_counts.csv", row.names = FALSE)
```

```{r check-bg-groups}
# Verify one BG per MAZ using 2010 vintage Block Groups
bgs <- map_dfr(county_fps, ~ get_decennial(
  geography = "block group",
  variables = "P1_001N",
  year      = 2010,
  state     = state_fp,
  county    = .x,
  geometry  = TRUE,
  output    = "wide"
)) %>%
  st_transform(4326) %>%
  st_make_valid()
bg_maz <- st_join(bgs, mazs_wgs, join = st_intersects)
bg_counts <- bg_maz %>%
  st_drop_geometry() %>%
  distinct(GEOID, MAZ_ID) %>%
  count(MAZ_ID, name = "bg_count")
print(summary(bg_counts$bg_count))
cat("MAZs with one BG:", sum(bg_counts$bg_count == 1), "\n")
cat("MAZs with multiple BGs:", sum(bg_counts$bg_count > 1), "\n")
write.csv(bg_counts, "maz_bg_counts.csv", row.names = FALSE)
```

```{r leaflet-map, message=FALSE}
# Plot Blocks and MAZs
gg_blocks <- blocks_wgs
map <- leaflet() %>%
  addTiles() %>%
  addPolygons(data = gg_blocks, color = "gray", weight = 0.5, fill = FALSE, group = "Blocks", label = ~GEOID) %>%
  addPolygons(data = mazs_wgs, color = "blue", weight = 1, fill = FALSE, group = "MAZs", label = ~MAZ_ID) %>%
  addLayersControl(overlayGroups = c("Blocks","MAZs"), options = layersControlOptions(collapsed = FALSE))
map
```

```{r save-map, eval=FALSE}
htmlwidgets::saveWidget(map, "maz_block_map.html", selfcontained = TRUE)
```

