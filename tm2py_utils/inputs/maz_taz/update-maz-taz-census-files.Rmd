```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(sf)
library(leaflet)
library(htmlwidgets)
library(tidycensus)
library(dplyr)
library(purrr)
```

```{r read-shapefiles}
# Define file paths
maz_path <- "C:/GitHub/tm2py-utils/tm2py_utils/inputs/maz_taz/shapefiles/mazs_TM2_v2_2.shp"
taz_path <- "C:/GitHub/tm2py-utils/tm2py_utils/inputs/maz_taz/shapefiles/tazs_TM2_v2_2.shp"

# Read shapefiles
mazs <- st_read(maz_path, quiet = TRUE)
tazs <- st_read(taz_path, quiet = TRUE)

# Reproject to WGS84 for Leaflet and tidycensus compatibility
crs_target <- 4326
mazs_wgs <- st_transform(mazs, crs_target)
tazs_wgs <- st_transform(tazs, crs_target)
```

```{r fetch-blocks, message=FALSE}
# Set your Census API key (run once)
key_path <- "M:/Data/Census/new_key/api-key"
if (file.exists(key_path)) {
  key <- readLines(key_path)
  census_api_key(key, install = TRUE, overwrite = TRUE)
} else {
  # Fallback: use existing environment variable or manually set
  if (Sys.getenv("CENSUS_API_KEY") == "") {
    stop("Census API key not found. Place it in M:/census_api_key.txt or set CENSUS_API_KEY env var.")
  }
}

# Identify unique state and counties in the TAZ shapefile
state_fp   <- unique(tazs_wgs$STATEFP)
county_fps <- unique(tazs_wgs$COUNTYFP)

# Download 2020 Census blocks for each county
blocks_list <- map(county_fps, function(county) {
  get_decennial(
    geography = "block",
    variables = "P1_001N",  # total population; geometry only is needed
    year = 2020,
    state = state_fp,
    county = county,
    geometry = TRUE,
    output = "wide"
  )
})
blocks <- do.call(rbind, blocks_list)

# Transform blocks to match CRS
blocks_wgs <- st_transform(blocks, crs_target)
```

```{r spatial-intersect}
# Assign MAZ and TAZ to blocks via spatial join
blocks_maz <- st_join(blocks_wgs, mazs_wgs, join = st_intersects, left = TRUE)
blocks_maz_taz <- st_join(blocks_maz, tazs_wgs, join = st_intersects, left = TRUE)

# Prepare lookup table
lookup_df <- blocks_maz_taz %>%
  st_drop_geometry() %>%
  transmute(
    GEOID20 = GEOID,
    maz      = MAZ_ID,
    taz      = TAZ_ID
  )

# Write CSV
write.csv(lookup_df, "block_maz_taz_lookup.csv", row.names = FALSE)
```

```{r leaflet-map, message=FALSE}
# Create interactive map including blocks
map <- leaflet() %>%
  addTiles() %>%
  addPolygons(data = tazs_wgs,
              color = "black", weight = 1,
              fill = FALSE, group = "TAZs") %>%
  addPolygons(data = mazs_wgs,
              color = "blue", fillOpacity = 0.3,
              group = "MAZs") %>%
  addPolygons(data = blocks_wgs,
              color = "gray", weight = 0.2, fill = FALSE,
              group = "Blocks") %>%
  addLayersControl(
    overlayGroups = c("Blocks", "MAZs", "TAZs"),
    options = layersControlOptions(collapsed = FALSE)
  )

map
```

```{r save-widget, eval=FALSE}
# Save the interactive map as a standalone HTML file
htmlwidgets::saveWidget(map, "maz_taz_block_map.html", selfcontained = TRUE)
```


